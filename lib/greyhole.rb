# Amahi Home Server
# Copyright (C) 2007-2010 Amahi Team
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License v3
# (29 June 2007), as published in the COPYING file.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# file COPYING for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Amahi
# team at http://www.amahi.org/ under "Contact Us."

require 'yaml'

# Driver for Greyhole http://greyhole.pommepause.com/
module Greyhole
	SUFFIX = "gh"
	USE_DOT_FILE = ".greyhole_uses_this"
	GH_DEFAULTS = { "delete_moves_to_attic" => "true",
			"email_to" => "root",
			"dir_selection_algorithm" => "most_available_space",
			"db_engine" => "mysql",
			#"db_path" => "/var/cache/greyhole.sqlite",
			"db_host" => "localhost", "db_user" => "greyhole", "db_pass" => "greyhole", "db_name" => "greyhole",
			"sticky_files" => "Music/",
			"greyhole_log_file" => "/var/log/greyhole.log",
			"df_cache_time" => "15",
			"balance_modified_files" => "false", "log_memory_usage" => "false",
			"other" => nil,
			# FIXME-cpg: change from DEBUG at some point - added 4 '10
			"log_level" => "DEBUG" }
	GH_DEFAULTS_FILE = "#{Rails.root}/config/greyhole.yml"

	# generate and write GH conf file
	def self.save_conf_file(partitions, shares)
		ghconf = "/tmp/greyhole-%d.%d" % [$$, rand(99999)]
		s = File.new ghconf, "w"
		s.write(self.greyhole_conf(partitions, shares))
		s.flush
		s.close
		c = Command.new
		c.submit("cp \"#{ghconf}\" /etc/greyhole.conf")
		c.submit("rm -f \"#{ghconf}\"")
		partitions.each do |p|
			ppath = part_path p
			# ensure it's a mountpoint - http://bugs.amahi.org/issues/show/611
			if Pathname.new(p.path).mountpoint?
				c.submit("mkdir -p \"#{ppath}\"")
				c.submit("touch \"#{ppath}/#{USE_DOT_FILE}\"")
			end
		end
		# reload greyhole
		c.submit("service greyhole condrestart")
		c.execute
	end

	def self.enabled?
		File.exist? "/etc/greyhole.conf"
	end

private

	# Generate GH conf file
	def self.greyhole_conf(partitions, shares)
		ret = self.header
		partitions.each do |p|
			# ensure it's a mountpoint
			ret += self.partition_conf(p) if Pathname.new(p.path).mountpoint?
		end
		shares.each do |s|
			ret += self.share_conf(s)
		end
		ret
	end

	def self.share_conf(s)
		"num_copies[#{s[:comment]}] = #{s[:disk_pool_copies]}\n"
	end

	def self.partition_conf(p)
		"storage_pool_directory = #{part_path p}, min_free: #{p[:minimum_free]}gb\n"
	end

	def self.part_path(p)
		File.join(p[:path], SUFFIX)
	end

	def self.header
		gh = GH_DEFAULTS
		begin
			gh.merge!(YAML::load(File.open(GH_DEFAULTS_FILE))) if File.exists?(GH_DEFAULTS_FILE)
		rescue
			# shh - fail silently instead of crash
		end
		# mysql settings
		mysql = ['db_host', 'db_user', 'db_pass', 'db_name'].map{|s| "#{s} = #{gh[s]}" }.join("\n")
		settings = ["# This file is automatically generated by Amahi on #{Time.now}",
			"# Any manual changes WILL BE OVERWRITTEN!",
			"# Set the defaults (carefully) in #{GH_DEFAULTS_FILE}",
			"db_engine = #{gh['db_engine']}",
			((gh['db_engine'] == 'sqlite') ? "db_path = #{gh['db_path']}" : mysql)]
		# rest of settings
		rest = ["balance_modified_files", "email_to", "greyhole_log_file", "log_level",
			"log_memory_usage", "dir_selection_algorithm", "df_cache_time",
			"delete_moves_to_attic"].map{|s| "#{s} = #{gh[s]}" }
		settings << rest
		settings << sticky_files_to_s(gh["sticky_files"])
		if gh['other']
			settings << gh['other']
			settings << ['']
		end
		settings.join "\n"
	end

	def self.sticky_files_to_s(data)
		if data.class == String
			# FIXME: this is still the old format - aug 1 20010
			# can be deprecated in amahi 6!
			return ["sticky_files = #{data}"]
		end
		# new format!
		res = ["# sticky_files and stick_into options are nested - see http://wiki.amahi.org/index.php/Greyhole#Greyhole_advanced_options"]
		data.map do |entry|
			pattern = entry[0]
			into = entry[1]
			res << "sticky_files = #{pattern}"
			res += into.map{ |dir| "\tstick_into = #{dir}" } if into
		end
		res
	end
end
